/*
 * Elastic Cloud API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ClusterLicenseInfo;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Information about a license.
 */
@Schema(description = "Information about a license.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-10T16:33:30.970+05:30[Asia/Kolkata]")
public class LicenseInfo {
  @SerializedName("version")
  private Integer version = null;

  @SerializedName("uid")
  private String uid = null;

  @SerializedName("issuer")
  private String issuer = null;

  @SerializedName("issued_to")
  private String issuedTo = null;

  @SerializedName("issue_date_in_millis")
  private Long issueDateInMillis = null;

  @SerializedName("type")
  private String type = null;

  @SerializedName("subscription_type")
  private String subscriptionType = null;

  @SerializedName("signature")
  private String signature = null;

  @SerializedName("start_date_in_millis")
  private Long startDateInMillis = null;

  @SerializedName("expiry_date_in_millis")
  private Long expiryDateInMillis = null;

  @SerializedName("max_allocators")
  private Integer maxAllocators = null;

  @SerializedName("max_ram_per_allocator_mb")
  private Integer maxRamPerAllocatorMb = null;

  @SerializedName("max_instances")
  private Integer maxInstances = null;

  @SerializedName("operation_mode")
  private String operationMode = null;

  @SerializedName("cluster_licenses")
  private List<ClusterLicenseInfo> clusterLicenses = null;

  public LicenseInfo version(Integer version) {
    this.version = version;
    return this;
  }

   /**
   * Version of the license
   * @return version
  **/
  @Schema(description = "Version of the license")
  public Integer getVersion() {
    return version;
  }

  public void setVersion(Integer version) {
    this.version = version;
  }

  public LicenseInfo uid(String uid) {
    this.uid = uid;
    return this;
  }

   /**
   * Unique identifier of the license
   * @return uid
  **/
  @Schema(required = true, description = "Unique identifier of the license")
  public String getUid() {
    return uid;
  }

  public void setUid(String uid) {
    this.uid = uid;
  }

  public LicenseInfo issuer(String issuer) {
    this.issuer = issuer;
    return this;
  }

   /**
   * Issuer of the license
   * @return issuer
  **/
  @Schema(required = true, description = "Issuer of the license")
  public String getIssuer() {
    return issuer;
  }

  public void setIssuer(String issuer) {
    this.issuer = issuer;
  }

  public LicenseInfo issuedTo(String issuedTo) {
    this.issuedTo = issuedTo;
    return this;
  }

   /**
   * Entity the license was issued to
   * @return issuedTo
  **/
  @Schema(required = true, description = "Entity the license was issued to")
  public String getIssuedTo() {
    return issuedTo;
  }

  public void setIssuedTo(String issuedTo) {
    this.issuedTo = issuedTo;
  }

  public LicenseInfo issueDateInMillis(Long issueDateInMillis) {
    this.issueDateInMillis = issueDateInMillis;
    return this;
  }

   /**
   * When the license was issued, in milliseconds since the Unix epoch
   * @return issueDateInMillis
  **/
  @Schema(required = true, description = "When the license was issued, in milliseconds since the Unix epoch")
  public Long getIssueDateInMillis() {
    return issueDateInMillis;
  }

  public void setIssueDateInMillis(Long issueDateInMillis) {
    this.issueDateInMillis = issueDateInMillis;
  }

  public LicenseInfo type(String type) {
    this.type = type;
    return this;
  }

   /**
   * Type of the license
   * @return type
  **/
  @Schema(required = true, description = "Type of the license")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public LicenseInfo subscriptionType(String subscriptionType) {
    this.subscriptionType = subscriptionType;
    return this;
  }

   /**
   * Type of the license subscription
   * @return subscriptionType
  **/
  @Schema(description = "Type of the license subscription")
  public String getSubscriptionType() {
    return subscriptionType;
  }

  public void setSubscriptionType(String subscriptionType) {
    this.subscriptionType = subscriptionType;
  }

  public LicenseInfo signature(String signature) {
    this.signature = signature;
    return this;
  }

   /**
   * Digital signature
   * @return signature
  **/
  @Schema(required = true, description = "Digital signature")
  public String getSignature() {
    return signature;
  }

  public void setSignature(String signature) {
    this.signature = signature;
  }

  public LicenseInfo startDateInMillis(Long startDateInMillis) {
    this.startDateInMillis = startDateInMillis;
    return this;
  }

   /**
   * Initial validity of the license, in milliseconds since the Unix epoch
   * @return startDateInMillis
  **/
  @Schema(required = true, description = "Initial validity of the license, in milliseconds since the Unix epoch")
  public Long getStartDateInMillis() {
    return startDateInMillis;
  }

  public void setStartDateInMillis(Long startDateInMillis) {
    this.startDateInMillis = startDateInMillis;
  }

  public LicenseInfo expiryDateInMillis(Long expiryDateInMillis) {
    this.expiryDateInMillis = expiryDateInMillis;
    return this;
  }

   /**
   * When the license expires, in milliseconds since the Unix epoch
   * @return expiryDateInMillis
  **/
  @Schema(required = true, description = "When the license expires, in milliseconds since the Unix epoch")
  public Long getExpiryDateInMillis() {
    return expiryDateInMillis;
  }

  public void setExpiryDateInMillis(Long expiryDateInMillis) {
    this.expiryDateInMillis = expiryDateInMillis;
  }

  public LicenseInfo maxAllocators(Integer maxAllocators) {
    this.maxAllocators = maxAllocators;
    return this;
  }

   /**
   * Maximum number of allocators. Empty for version &gt;&#x3D; 3
   * @return maxAllocators
  **/
  @Schema(description = "Maximum number of allocators. Empty for version >= 3")
  public Integer getMaxAllocators() {
    return maxAllocators;
  }

  public void setMaxAllocators(Integer maxAllocators) {
    this.maxAllocators = maxAllocators;
  }

  public LicenseInfo maxRamPerAllocatorMb(Integer maxRamPerAllocatorMb) {
    this.maxRamPerAllocatorMb = maxRamPerAllocatorMb;
    return this;
  }

   /**
   * Maximum RAM per allocator in MB. Empty for version &gt;&#x3D; 3
   * @return maxRamPerAllocatorMb
  **/
  @Schema(description = "Maximum RAM per allocator in MB. Empty for version >= 3")
  public Integer getMaxRamPerAllocatorMb() {
    return maxRamPerAllocatorMb;
  }

  public void setMaxRamPerAllocatorMb(Integer maxRamPerAllocatorMb) {
    this.maxRamPerAllocatorMb = maxRamPerAllocatorMb;
  }

  public LicenseInfo maxInstances(Integer maxInstances) {
    this.maxInstances = maxInstances;
    return this;
  }

   /**
   * Maximum number of instances. Only present for version 3
   * @return maxInstances
  **/
  @Schema(description = "Maximum number of instances. Only present for version 3")
  public Integer getMaxInstances() {
    return maxInstances;
  }

  public void setMaxInstances(Integer maxInstances) {
    this.maxInstances = maxInstances;
  }

  public LicenseInfo operationMode(String operationMode) {
    this.operationMode = operationMode;
    return this;
  }

   /**
   * Operation mode
   * @return operationMode
  **/
  @Schema(description = "Operation mode")
  public String getOperationMode() {
    return operationMode;
  }

  public void setOperationMode(String operationMode) {
    this.operationMode = operationMode;
  }

  public LicenseInfo clusterLicenses(List<ClusterLicenseInfo> clusterLicenses) {
    this.clusterLicenses = clusterLicenses;
    return this;
  }

  public LicenseInfo addClusterLicensesItem(ClusterLicenseInfo clusterLicensesItem) {
    if (this.clusterLicenses == null) {
      this.clusterLicenses = new ArrayList<ClusterLicenseInfo>();
    }
    this.clusterLicenses.add(clusterLicensesItem);
    return this;
  }

   /**
   * List of cluster licenses
   * @return clusterLicenses
  **/
  @Schema(description = "List of cluster licenses")
  public List<ClusterLicenseInfo> getClusterLicenses() {
    return clusterLicenses;
  }

  public void setClusterLicenses(List<ClusterLicenseInfo> clusterLicenses) {
    this.clusterLicenses = clusterLicenses;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LicenseInfo licenseInfo = (LicenseInfo) o;
    return Objects.equals(this.version, licenseInfo.version) &&
        Objects.equals(this.uid, licenseInfo.uid) &&
        Objects.equals(this.issuer, licenseInfo.issuer) &&
        Objects.equals(this.issuedTo, licenseInfo.issuedTo) &&
        Objects.equals(this.issueDateInMillis, licenseInfo.issueDateInMillis) &&
        Objects.equals(this.type, licenseInfo.type) &&
        Objects.equals(this.subscriptionType, licenseInfo.subscriptionType) &&
        Objects.equals(this.signature, licenseInfo.signature) &&
        Objects.equals(this.startDateInMillis, licenseInfo.startDateInMillis) &&
        Objects.equals(this.expiryDateInMillis, licenseInfo.expiryDateInMillis) &&
        Objects.equals(this.maxAllocators, licenseInfo.maxAllocators) &&
        Objects.equals(this.maxRamPerAllocatorMb, licenseInfo.maxRamPerAllocatorMb) &&
        Objects.equals(this.maxInstances, licenseInfo.maxInstances) &&
        Objects.equals(this.operationMode, licenseInfo.operationMode) &&
        Objects.equals(this.clusterLicenses, licenseInfo.clusterLicenses);
  }

  @Override
  public int hashCode() {
    return Objects.hash(version, uid, issuer, issuedTo, issueDateInMillis, type, subscriptionType, signature, startDateInMillis, expiryDateInMillis, maxAllocators, maxRamPerAllocatorMb, maxInstances, operationMode, clusterLicenses);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LicenseInfo {\n");
    
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    uid: ").append(toIndentedString(uid)).append("\n");
    sb.append("    issuer: ").append(toIndentedString(issuer)).append("\n");
    sb.append("    issuedTo: ").append(toIndentedString(issuedTo)).append("\n");
    sb.append("    issueDateInMillis: ").append(toIndentedString(issueDateInMillis)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    subscriptionType: ").append(toIndentedString(subscriptionType)).append("\n");
    sb.append("    signature: ").append(toIndentedString(signature)).append("\n");
    sb.append("    startDateInMillis: ").append(toIndentedString(startDateInMillis)).append("\n");
    sb.append("    expiryDateInMillis: ").append(toIndentedString(expiryDateInMillis)).append("\n");
    sb.append("    maxAllocators: ").append(toIndentedString(maxAllocators)).append("\n");
    sb.append("    maxRamPerAllocatorMb: ").append(toIndentedString(maxRamPerAllocatorMb)).append("\n");
    sb.append("    maxInstances: ").append(toIndentedString(maxInstances)).append("\n");
    sb.append("    operationMode: ").append(toIndentedString(operationMode)).append("\n");
    sb.append("    clusterLicenses: ").append(toIndentedString(clusterLicenses)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
