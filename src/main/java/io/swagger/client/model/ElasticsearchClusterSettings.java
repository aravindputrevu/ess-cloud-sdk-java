/*
 * Elastic Cloud API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ClusterCurationSettings;
import io.swagger.client.model.ClusterMetadataSettings;
import io.swagger.client.model.ClusterSnapshotSettings;
import io.swagger.client.model.CrossClusterSearchSettings;
import io.swagger.client.model.IpFilteringSettings;
import io.swagger.client.model.ManagedMonitoringSettings;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * The settings for an Elasticsearch cluster.
 */
@Schema(description = "The settings for an Elasticsearch cluster.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-10T16:33:30.970+05:30[Asia/Kolkata]")
public class ElasticsearchClusterSettings {
  @SerializedName("snapshot")
  private ClusterSnapshotSettings snapshot = null;

  @SerializedName("monitoring")
  private ManagedMonitoringSettings monitoring = null;

  @SerializedName("metadata")
  private ClusterMetadataSettings metadata = null;

  @SerializedName("curation")
  private ClusterCurationSettings curation = null;

  @SerializedName("dedicated_masters_threshold")
  private Integer dedicatedMastersThreshold = null;

  @SerializedName("ip_filtering")
  private IpFilteringSettings ipFiltering = null;

  @SerializedName("ccs")
  private CrossClusterSearchSettings ccs = null;

  public ElasticsearchClusterSettings snapshot(ClusterSnapshotSettings snapshot) {
    this.snapshot = snapshot;
    return this;
  }

   /**
   * Get snapshot
   * @return snapshot
  **/
  @Schema(description = "")
  public ClusterSnapshotSettings getSnapshot() {
    return snapshot;
  }

  public void setSnapshot(ClusterSnapshotSettings snapshot) {
    this.snapshot = snapshot;
  }

  public ElasticsearchClusterSettings monitoring(ManagedMonitoringSettings monitoring) {
    this.monitoring = monitoring;
    return this;
  }

   /**
   * Get monitoring
   * @return monitoring
  **/
  @Schema(description = "")
  public ManagedMonitoringSettings getMonitoring() {
    return monitoring;
  }

  public void setMonitoring(ManagedMonitoringSettings monitoring) {
    this.monitoring = monitoring;
  }

  public ElasticsearchClusterSettings metadata(ClusterMetadataSettings metadata) {
    this.metadata = metadata;
    return this;
  }

   /**
   * Get metadata
   * @return metadata
  **/
  @Schema(description = "")
  public ClusterMetadataSettings getMetadata() {
    return metadata;
  }

  public void setMetadata(ClusterMetadataSettings metadata) {
    this.metadata = metadata;
  }

  public ElasticsearchClusterSettings curation(ClusterCurationSettings curation) {
    this.curation = curation;
    return this;
  }

   /**
   * Get curation
   * @return curation
  **/
  @Schema(description = "")
  public ClusterCurationSettings getCuration() {
    return curation;
  }

  public void setCuration(ClusterCurationSettings curation) {
    this.curation = curation;
  }

  public ElasticsearchClusterSettings dedicatedMastersThreshold(Integer dedicatedMastersThreshold) {
    this.dedicatedMastersThreshold = dedicatedMastersThreshold;
    return this;
  }

   /**
   * Threshold starting from which the number of instances in the cluster results in the introduction of dedicated masters. If the cluster is downscaled to a number of nodes below this one, dedicated masters will be removed. Limit is inclusive.
   * @return dedicatedMastersThreshold
  **/
  @Schema(description = "Threshold starting from which the number of instances in the cluster results in the introduction of dedicated masters. If the cluster is downscaled to a number of nodes below this one, dedicated masters will be removed. Limit is inclusive.")
  public Integer getDedicatedMastersThreshold() {
    return dedicatedMastersThreshold;
  }

  public void setDedicatedMastersThreshold(Integer dedicatedMastersThreshold) {
    this.dedicatedMastersThreshold = dedicatedMastersThreshold;
  }

  public ElasticsearchClusterSettings ipFiltering(IpFilteringSettings ipFiltering) {
    this.ipFiltering = ipFiltering;
    return this;
  }

   /**
   * Get ipFiltering
   * @return ipFiltering
  **/
  @Schema(description = "")
  public IpFilteringSettings getIpFiltering() {
    return ipFiltering;
  }

  public void setIpFiltering(IpFilteringSettings ipFiltering) {
    this.ipFiltering = ipFiltering;
  }

  public ElasticsearchClusterSettings ccs(CrossClusterSearchSettings ccs) {
    this.ccs = ccs;
    return this;
  }

   /**
   * Get ccs
   * @return ccs
  **/
  @Schema(description = "")
  public CrossClusterSearchSettings getCcs() {
    return ccs;
  }

  public void setCcs(CrossClusterSearchSettings ccs) {
    this.ccs = ccs;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ElasticsearchClusterSettings elasticsearchClusterSettings = (ElasticsearchClusterSettings) o;
    return Objects.equals(this.snapshot, elasticsearchClusterSettings.snapshot) &&
        Objects.equals(this.monitoring, elasticsearchClusterSettings.monitoring) &&
        Objects.equals(this.metadata, elasticsearchClusterSettings.metadata) &&
        Objects.equals(this.curation, elasticsearchClusterSettings.curation) &&
        Objects.equals(this.dedicatedMastersThreshold, elasticsearchClusterSettings.dedicatedMastersThreshold) &&
        Objects.equals(this.ipFiltering, elasticsearchClusterSettings.ipFiltering) &&
        Objects.equals(this.ccs, elasticsearchClusterSettings.ccs);
  }

  @Override
  public int hashCode() {
    return Objects.hash(snapshot, monitoring, metadata, curation, dedicatedMastersThreshold, ipFiltering, ccs);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ElasticsearchClusterSettings {\n");
    
    sb.append("    snapshot: ").append(toIndentedString(snapshot)).append("\n");
    sb.append("    monitoring: ").append(toIndentedString(monitoring)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    curation: ").append(toIndentedString(curation)).append("\n");
    sb.append("    dedicatedMastersThreshold: ").append(toIndentedString(dedicatedMastersThreshold)).append("\n");
    sb.append("    ipFiltering: ").append(toIndentedString(ipFiltering)).append("\n");
    sb.append("    ccs: ").append(toIndentedString(ccs)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
