/*
 * Elastic Cloud API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ElasticsearchScriptingUserSettings;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * A subset of Elasticsearch settings. TIP: To define the complete set of Elasticsearch settings, use &#x60;ElasticsearchSystemSettings&#x60; with &#x60;user_settings_override*&#x60; and &#x60;user_settings*&#x60;.
 */
@Schema(description = "A subset of Elasticsearch settings. TIP: To define the complete set of Elasticsearch settings, use `ElasticsearchSystemSettings` with `user_settings_override*` and `user_settings*`.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-10T16:33:30.970+05:30[Asia/Kolkata]")
public class ElasticsearchSystemSettings {
  @SerializedName("scripting")
  private ElasticsearchScriptingUserSettings scripting = null;

  @SerializedName("reindex_whitelist")
  private List<String> reindexWhitelist = null;

  @SerializedName("use_disk_threshold")
  private Boolean useDiskThreshold = null;

  @SerializedName("auto_create_index")
  private Boolean autoCreateIndex = null;

  @SerializedName("enable_close_index")
  private Boolean enableCloseIndex = null;

  @SerializedName("destructive_requires_name")
  private Boolean destructiveRequiresName = null;

  @SerializedName("watcher_trigger_engine")
  private String watcherTriggerEngine = null;

  @SerializedName("default_shards_per_index")
  private Integer defaultShardsPerIndex = null;

  @SerializedName("monitoring_collection_interval")
  private Integer monitoringCollectionInterval = null;

  @SerializedName("monitoring_history_duration")
  private String monitoringHistoryDuration = null;

  public ElasticsearchSystemSettings scripting(ElasticsearchScriptingUserSettings scripting) {
    this.scripting = scripting;
    return this;
  }

   /**
   * Get scripting
   * @return scripting
  **/
  @Schema(description = "")
  public ElasticsearchScriptingUserSettings getScripting() {
    return scripting;
  }

  public void setScripting(ElasticsearchScriptingUserSettings scripting) {
    this.scripting = scripting;
  }

  public ElasticsearchSystemSettings reindexWhitelist(List<String> reindexWhitelist) {
    this.reindexWhitelist = reindexWhitelist;
    return this;
  }

  public ElasticsearchSystemSettings addReindexWhitelistItem(String reindexWhitelistItem) {
    if (this.reindexWhitelist == null) {
      this.reindexWhitelist = new ArrayList<String>();
    }
    this.reindexWhitelist.add(reindexWhitelistItem);
    return this;
  }

   /**
   * Limits remote Elasticsearch clusters that can be used as the source for &#x27;_reindex&#x27; API commands
   * @return reindexWhitelist
  **/
  @Schema(description = "Limits remote Elasticsearch clusters that can be used as the source for '_reindex' API commands")
  public List<String> getReindexWhitelist() {
    return reindexWhitelist;
  }

  public void setReindexWhitelist(List<String> reindexWhitelist) {
    this.reindexWhitelist = reindexWhitelist;
  }

  public ElasticsearchSystemSettings useDiskThreshold(Boolean useDiskThreshold) {
    this.useDiskThreshold = useDiskThreshold;
    return this;
  }

   /**
   * Whether to factor in the available disk space on a node before deciding whether to allocate new shards to that node or actively relocate shards away from the node (default: true). NOTES: (Corresponds to the parameter &#x27;cluster.routing.allocation.disk.threshold_enabled&#x27;)
   * @return useDiskThreshold
  **/
  @Schema(description = "Whether to factor in the available disk space on a node before deciding whether to allocate new shards to that node or actively relocate shards away from the node (default: true). NOTES: (Corresponds to the parameter 'cluster.routing.allocation.disk.threshold_enabled')")
  public Boolean isUseDiskThreshold() {
    return useDiskThreshold;
  }

  public void setUseDiskThreshold(Boolean useDiskThreshold) {
    this.useDiskThreshold = useDiskThreshold;
  }

  public ElasticsearchSystemSettings autoCreateIndex(Boolean autoCreateIndex) {
    this.autoCreateIndex = autoCreateIndex;
    return this;
  }

   /**
   * If true (the default), then any write operation on an index that does not currently exist will create it. NOTES: (Corresponds to the parameter &#x27;action.auto_create_index&#x27;)
   * @return autoCreateIndex
  **/
  @Schema(description = "If true (the default), then any write operation on an index that does not currently exist will create it. NOTES: (Corresponds to the parameter 'action.auto_create_index')")
  public Boolean isAutoCreateIndex() {
    return autoCreateIndex;
  }

  public void setAutoCreateIndex(Boolean autoCreateIndex) {
    this.autoCreateIndex = autoCreateIndex;
  }

  public ElasticsearchSystemSettings enableCloseIndex(Boolean enableCloseIndex) {
    this.enableCloseIndex = enableCloseIndex;
    return this;
  }

   /**
   * Defaults to false on versions &lt;&#x3D; 7.2.0, true otherwise. If false, then the API commands to close indices are disabled. This is important because Elasticsearch does not snapshot or migrate close indices on versions under 7.2.0, therefore standard Elastic Cloud configuration operations will cause irretrievable loss of indices&#x27; data. NOTES: (Corresponds to the parameter &#x27;cluster.indices.close.enable&#x27;)
   * @return enableCloseIndex
  **/
  @Schema(description = "Defaults to false on versions <= 7.2.0, true otherwise. If false, then the API commands to close indices are disabled. This is important because Elasticsearch does not snapshot or migrate close indices on versions under 7.2.0, therefore standard Elastic Cloud configuration operations will cause irretrievable loss of indices' data. NOTES: (Corresponds to the parameter 'cluster.indices.close.enable')")
  public Boolean isEnableCloseIndex() {
    return enableCloseIndex;
  }

  public void setEnableCloseIndex(Boolean enableCloseIndex) {
    this.enableCloseIndex = enableCloseIndex;
  }

  public ElasticsearchSystemSettings destructiveRequiresName(Boolean destructiveRequiresName) {
    this.destructiveRequiresName = destructiveRequiresName;
    return this;
  }

   /**
   * If true (default is false) then the index deletion API will not support wildcards or &#x27;_all&#x27;. NOTES: (Corresponds to the parameter &#x27;action.destructive_requires_name&#x27;)
   * @return destructiveRequiresName
  **/
  @Schema(description = "If true (default is false) then the index deletion API will not support wildcards or '_all'. NOTES: (Corresponds to the parameter 'action.destructive_requires_name')")
  public Boolean isDestructiveRequiresName() {
    return destructiveRequiresName;
  }

  public void setDestructiveRequiresName(Boolean destructiveRequiresName) {
    this.destructiveRequiresName = destructiveRequiresName;
  }

  public ElasticsearchSystemSettings watcherTriggerEngine(String watcherTriggerEngine) {
    this.watcherTriggerEngine = watcherTriggerEngine;
    return this;
  }

   /**
   * The trigger engine for Watcher, defaults to &#x27;scheduler&#x27; - see the xpack documentation for more information. NOTES: (Corresponds to the parameter &#x27;(xpack.)watcher.trigger.schedule.engine&#x27;, depending on version. Ignored from 6.x onwards.)
   * @return watcherTriggerEngine
  **/
  @Schema(description = "The trigger engine for Watcher, defaults to 'scheduler' - see the xpack documentation for more information. NOTES: (Corresponds to the parameter '(xpack.)watcher.trigger.schedule.engine', depending on version. Ignored from 6.x onwards.)")
  public String getWatcherTriggerEngine() {
    return watcherTriggerEngine;
  }

  public void setWatcherTriggerEngine(String watcherTriggerEngine) {
    this.watcherTriggerEngine = watcherTriggerEngine;
  }

  public ElasticsearchSystemSettings defaultShardsPerIndex(Integer defaultShardsPerIndex) {
    this.defaultShardsPerIndex = defaultShardsPerIndex;
    return this;
  }

   /**
   * (2.x only - to get the same result in 5.x template mappings must be used) Sets the default number of shards per index, defaulting to 1 if not specified. (Corresponds to the parameter &#x27;index.number_of_shards&#x27; in 2.x, not supported in 5.x)
   * @return defaultShardsPerIndex
  **/
  @Schema(description = "(2.x only - to get the same result in 5.x template mappings must be used) Sets the default number of shards per index, defaulting to 1 if not specified. (Corresponds to the parameter 'index.number_of_shards' in 2.x, not supported in 5.x)")
  public Integer getDefaultShardsPerIndex() {
    return defaultShardsPerIndex;
  }

  public void setDefaultShardsPerIndex(Integer defaultShardsPerIndex) {
    this.defaultShardsPerIndex = defaultShardsPerIndex;
  }

  public ElasticsearchSystemSettings monitoringCollectionInterval(Integer monitoringCollectionInterval) {
    this.monitoringCollectionInterval = monitoringCollectionInterval;
    return this;
  }

   /**
   * The default interval at which monitoring information from the cluster if collected, if monitoring is enabled. NOTES: (Corresponds to the parameter &#x27;marvel.agent.interval&#x27; in 2.x and &#x27;xpack.monitoring.collection.interval&#x27; in 5.x)
   * @return monitoringCollectionInterval
  **/
  @Schema(description = "The default interval at which monitoring information from the cluster if collected, if monitoring is enabled. NOTES: (Corresponds to the parameter 'marvel.agent.interval' in 2.x and 'xpack.monitoring.collection.interval' in 5.x)")
  public Integer getMonitoringCollectionInterval() {
    return monitoringCollectionInterval;
  }

  public void setMonitoringCollectionInterval(Integer monitoringCollectionInterval) {
    this.monitoringCollectionInterval = monitoringCollectionInterval;
  }

  public ElasticsearchSystemSettings monitoringHistoryDuration(String monitoringHistoryDuration) {
    this.monitoringHistoryDuration = monitoringHistoryDuration;
    return this;
  }

   /**
   * The duration for which monitoring history is stored (format &#x27;(NUMBER)d&#x27; eg &#x27;3d&#x27; for 3 days). NOTES: (&#x27;Corresponds to the parameter xpack.monitoring.history.duration&#x27; in 5.x, defaults to &#x27;7d&#x27;)
   * @return monitoringHistoryDuration
  **/
  @Schema(description = "The duration for which monitoring history is stored (format '(NUMBER)d' eg '3d' for 3 days). NOTES: ('Corresponds to the parameter xpack.monitoring.history.duration' in 5.x, defaults to '7d')")
  public String getMonitoringHistoryDuration() {
    return monitoringHistoryDuration;
  }

  public void setMonitoringHistoryDuration(String monitoringHistoryDuration) {
    this.monitoringHistoryDuration = monitoringHistoryDuration;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ElasticsearchSystemSettings elasticsearchSystemSettings = (ElasticsearchSystemSettings) o;
    return Objects.equals(this.scripting, elasticsearchSystemSettings.scripting) &&
        Objects.equals(this.reindexWhitelist, elasticsearchSystemSettings.reindexWhitelist) &&
        Objects.equals(this.useDiskThreshold, elasticsearchSystemSettings.useDiskThreshold) &&
        Objects.equals(this.autoCreateIndex, elasticsearchSystemSettings.autoCreateIndex) &&
        Objects.equals(this.enableCloseIndex, elasticsearchSystemSettings.enableCloseIndex) &&
        Objects.equals(this.destructiveRequiresName, elasticsearchSystemSettings.destructiveRequiresName) &&
        Objects.equals(this.watcherTriggerEngine, elasticsearchSystemSettings.watcherTriggerEngine) &&
        Objects.equals(this.defaultShardsPerIndex, elasticsearchSystemSettings.defaultShardsPerIndex) &&
        Objects.equals(this.monitoringCollectionInterval, elasticsearchSystemSettings.monitoringCollectionInterval) &&
        Objects.equals(this.monitoringHistoryDuration, elasticsearchSystemSettings.monitoringHistoryDuration);
  }

  @Override
  public int hashCode() {
    return Objects.hash(scripting, reindexWhitelist, useDiskThreshold, autoCreateIndex, enableCloseIndex, destructiveRequiresName, watcherTriggerEngine, defaultShardsPerIndex, monitoringCollectionInterval, monitoringHistoryDuration);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ElasticsearchSystemSettings {\n");
    
    sb.append("    scripting: ").append(toIndentedString(scripting)).append("\n");
    sb.append("    reindexWhitelist: ").append(toIndentedString(reindexWhitelist)).append("\n");
    sb.append("    useDiskThreshold: ").append(toIndentedString(useDiskThreshold)).append("\n");
    sb.append("    autoCreateIndex: ").append(toIndentedString(autoCreateIndex)).append("\n");
    sb.append("    enableCloseIndex: ").append(toIndentedString(enableCloseIndex)).append("\n");
    sb.append("    destructiveRequiresName: ").append(toIndentedString(destructiveRequiresName)).append("\n");
    sb.append("    watcherTriggerEngine: ").append(toIndentedString(watcherTriggerEngine)).append("\n");
    sb.append("    defaultShardsPerIndex: ").append(toIndentedString(defaultShardsPerIndex)).append("\n");
    sb.append("    monitoringCollectionInterval: ").append(toIndentedString(monitoringCollectionInterval)).append("\n");
    sb.append("    monitoringHistoryDuration: ").append(toIndentedString(monitoringHistoryDuration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
