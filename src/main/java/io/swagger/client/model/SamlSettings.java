/*
 * Elastic Cloud API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.SamlAttributeSettings;
import io.swagger.client.model.SamlIdpSettings;
import io.swagger.client.model.SamlSecurityRealmRoleMappingRules;
import io.swagger.client.model.SamlSpSettings;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * The configuration for the Elasticsearch security SAML realm.
 */
@Schema(description = "The configuration for the Elasticsearch security SAML realm.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-10T16:33:30.970+05:30[Asia/Kolkata]")
public class SamlSettings {
  @SerializedName("id")
  private String id = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("idp")
  private SamlIdpSettings idp = null;

  @SerializedName("sp")
  private SamlSpSettings sp = null;

  @SerializedName("attributes")
  private SamlAttributeSettings attributes = null;

  @SerializedName("role_mappings")
  private SamlSecurityRealmRoleMappingRules roleMappings = null;

  @SerializedName("enabled")
  private Boolean enabled = null;

  @SerializedName("order")
  private Integer order = null;

  @SerializedName("force_authn")
  private Boolean forceAuthn = null;

  @SerializedName("signing_certificate_url")
  private String signingCertificateUrl = null;

  @SerializedName("signing_certificate_url_password")
  private String signingCertificateUrlPassword = null;

  @SerializedName("signing_saml_messages")
  private List<String> signingSamlMessages = null;

  @SerializedName("encryption_certificate_url")
  private String encryptionCertificateUrl = null;

  @SerializedName("encryption_certificate_url_password")
  private String encryptionCertificateUrlPassword = null;

  @SerializedName("ssl_certificate_url")
  private String sslCertificateUrl = null;

  @SerializedName("ssl_certificate_url_truststore_password")
  private String sslCertificateUrlTruststorePassword = null;

  /**
   * The format of the keystore file. Should be jks to use the Java Keystore format or PKCS12 to use PKCS#12 files. The default is jks.
   */
  @JsonAdapter(SslCertificateUrlTruststoreTypeEnum.Adapter.class)
  public enum SslCertificateUrlTruststoreTypeEnum {
    JKS("jks"),
    PKCS12("PKCS12");

    private String value;

    SslCertificateUrlTruststoreTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SslCertificateUrlTruststoreTypeEnum fromValue(String text) {
      for (SslCertificateUrlTruststoreTypeEnum b : SslCertificateUrlTruststoreTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SslCertificateUrlTruststoreTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SslCertificateUrlTruststoreTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SslCertificateUrlTruststoreTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SslCertificateUrlTruststoreTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("ssl_certificate_url_truststore_type")
  private SslCertificateUrlTruststoreTypeEnum sslCertificateUrlTruststoreType = null;

  @SerializedName("override_yaml")
  private String overrideYaml = null;

  public SamlSettings id(String id) {
    this.id = id;
    return this;
  }

   /**
   * The identifier for the security realm
   * @return id
  **/
  @Schema(required = true, description = "The identifier for the security realm")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public SamlSettings name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The friendly name of the security realm
   * @return name
  **/
  @Schema(required = true, description = "The friendly name of the security realm")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public SamlSettings idp(SamlIdpSettings idp) {
    this.idp = idp;
    return this;
  }

   /**
   * Get idp
   * @return idp
  **/
  @Schema(required = true, description = "")
  public SamlIdpSettings getIdp() {
    return idp;
  }

  public void setIdp(SamlIdpSettings idp) {
    this.idp = idp;
  }

  public SamlSettings sp(SamlSpSettings sp) {
    this.sp = sp;
    return this;
  }

   /**
   * Get sp
   * @return sp
  **/
  @Schema(required = true, description = "")
  public SamlSpSettings getSp() {
    return sp;
  }

  public void setSp(SamlSpSettings sp) {
    this.sp = sp;
  }

  public SamlSettings attributes(SamlAttributeSettings attributes) {
    this.attributes = attributes;
    return this;
  }

   /**
   * Get attributes
   * @return attributes
  **/
  @Schema(required = true, description = "")
  public SamlAttributeSettings getAttributes() {
    return attributes;
  }

  public void setAttributes(SamlAttributeSettings attributes) {
    this.attributes = attributes;
  }

  public SamlSettings roleMappings(SamlSecurityRealmRoleMappingRules roleMappings) {
    this.roleMappings = roleMappings;
    return this;
  }

   /**
   * Get roleMappings
   * @return roleMappings
  **/
  @Schema(description = "")
  public SamlSecurityRealmRoleMappingRules getRoleMappings() {
    return roleMappings;
  }

  public void setRoleMappings(SamlSecurityRealmRoleMappingRules roleMappings) {
    this.roleMappings = roleMappings;
  }

  public SamlSettings enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

   /**
   * When true, enables the security realm
   * @return enabled
  **/
  @Schema(description = "When true, enables the security realm")
  public Boolean isEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }

  public SamlSettings order(Integer order) {
    this.order = order;
    return this;
  }

   /**
   * The order that the security realm is evaluated
   * @return order
  **/
  @Schema(description = "The order that the security realm is evaluated")
  public Integer getOrder() {
    return order;
  }

  public void setOrder(Integer order) {
    this.order = order;
  }

  public SamlSettings forceAuthn(Boolean forceAuthn) {
    this.forceAuthn = forceAuthn;
    return this;
  }

   /**
   * Specifies whether to set the ForceAuthn attribute when requesting that the IdP authenticate the current user. If set to true, the IdP is required to verify the user&#x27;s identity, irrespective of any existing sessions they might have.
   * @return forceAuthn
  **/
  @Schema(description = "Specifies whether to set the ForceAuthn attribute when requesting that the IdP authenticate the current user. If set to true, the IdP is required to verify the user's identity, irrespective of any existing sessions they might have.")
  public Boolean isForceAuthn() {
    return forceAuthn;
  }

  public void setForceAuthn(Boolean forceAuthn) {
    this.forceAuthn = forceAuthn;
  }

  public SamlSettings signingCertificateUrl(String signingCertificateUrl) {
    this.signingCertificateUrl = signingCertificateUrl;
    return this;
  }

   /**
   * The SAML signing certificate bundle URL. The bundle should be a zip file containing &#x27;signing.key&#x27; and &#x27;signing.pem&#x27; files in the directory &#x27;/saml/:id&#x27;, where :id is the value of the [id] field.
   * @return signingCertificateUrl
  **/
  @Schema(description = "The SAML signing certificate bundle URL. The bundle should be a zip file containing 'signing.key' and 'signing.pem' files in the directory '/saml/:id', where :id is the value of the [id] field.")
  public String getSigningCertificateUrl() {
    return signingCertificateUrl;
  }

  public void setSigningCertificateUrl(String signingCertificateUrl) {
    this.signingCertificateUrl = signingCertificateUrl;
  }

  public SamlSettings signingCertificateUrlPassword(String signingCertificateUrlPassword) {
    this.signingCertificateUrlPassword = signingCertificateUrlPassword;
    return this;
  }

   /**
   * The password to the signing certificate bundle
   * @return signingCertificateUrlPassword
  **/
  @Schema(description = "The password to the signing certificate bundle")
  public String getSigningCertificateUrlPassword() {
    return signingCertificateUrlPassword;
  }

  public void setSigningCertificateUrlPassword(String signingCertificateUrlPassword) {
    this.signingCertificateUrlPassword = signingCertificateUrlPassword;
  }

  public SamlSettings signingSamlMessages(List<String> signingSamlMessages) {
    this.signingSamlMessages = signingSamlMessages;
    return this;
  }

  public SamlSettings addSigningSamlMessagesItem(String signingSamlMessagesItem) {
    if (this.signingSamlMessages == null) {
      this.signingSamlMessages = new ArrayList<String>();
    }
    this.signingSamlMessages.add(signingSamlMessagesItem);
    return this;
  }

   /**
   * A list of SAML message types that should be signed. Each element in the list should be the local name of a SAML XML Element. Supported element types are AuthnRequest, LogoutRequest and LogoutResponse. Only valid if a signing certificate is also specified.
   * @return signingSamlMessages
  **/
  @Schema(description = "A list of SAML message types that should be signed. Each element in the list should be the local name of a SAML XML Element. Supported element types are AuthnRequest, LogoutRequest and LogoutResponse. Only valid if a signing certificate is also specified.")
  public List<String> getSigningSamlMessages() {
    return signingSamlMessages;
  }

  public void setSigningSamlMessages(List<String> signingSamlMessages) {
    this.signingSamlMessages = signingSamlMessages;
  }

  public SamlSettings encryptionCertificateUrl(String encryptionCertificateUrl) {
    this.encryptionCertificateUrl = encryptionCertificateUrl;
    return this;
  }

   /**
   * The SAML encryption certificate bundle URL. The bundle should be a zip file containing &#x27;encryption.key&#x27; and &#x27;encryption.pem&#x27; files in the directory &#x27;/saml/:id&#x27;, where :id is the value of the [id] field.
   * @return encryptionCertificateUrl
  **/
  @Schema(description = "The SAML encryption certificate bundle URL. The bundle should be a zip file containing 'encryption.key' and 'encryption.pem' files in the directory '/saml/:id', where :id is the value of the [id] field.")
  public String getEncryptionCertificateUrl() {
    return encryptionCertificateUrl;
  }

  public void setEncryptionCertificateUrl(String encryptionCertificateUrl) {
    this.encryptionCertificateUrl = encryptionCertificateUrl;
  }

  public SamlSettings encryptionCertificateUrlPassword(String encryptionCertificateUrlPassword) {
    this.encryptionCertificateUrlPassword = encryptionCertificateUrlPassword;
    return this;
  }

   /**
   * The password to the encryption certificate bundle
   * @return encryptionCertificateUrlPassword
  **/
  @Schema(description = "The password to the encryption certificate bundle")
  public String getEncryptionCertificateUrlPassword() {
    return encryptionCertificateUrlPassword;
  }

  public void setEncryptionCertificateUrlPassword(String encryptionCertificateUrlPassword) {
    this.encryptionCertificateUrlPassword = encryptionCertificateUrlPassword;
  }

  public SamlSettings sslCertificateUrl(String sslCertificateUrl) {
    this.sslCertificateUrl = sslCertificateUrl;
    return this;
  }

   /**
   * The SSL trusted CA certificate bundle URL. The bundle should be a zip file containing a single keystore file &#x27;keystore.ks&#x27; in the directory &#x27;/saml/:id/truststore&#x27;, where :id is the value of the [id] field.
   * @return sslCertificateUrl
  **/
  @Schema(description = "The SSL trusted CA certificate bundle URL. The bundle should be a zip file containing a single keystore file 'keystore.ks' in the directory '/saml/:id/truststore', where :id is the value of the [id] field.")
  public String getSslCertificateUrl() {
    return sslCertificateUrl;
  }

  public void setSslCertificateUrl(String sslCertificateUrl) {
    this.sslCertificateUrl = sslCertificateUrl;
  }

  public SamlSettings sslCertificateUrlTruststorePassword(String sslCertificateUrlTruststorePassword) {
    this.sslCertificateUrlTruststorePassword = sslCertificateUrlTruststorePassword;
    return this;
  }

   /**
   * The password to the SSL certificate bundle URL truststore
   * @return sslCertificateUrlTruststorePassword
  **/
  @Schema(description = "The password to the SSL certificate bundle URL truststore")
  public String getSslCertificateUrlTruststorePassword() {
    return sslCertificateUrlTruststorePassword;
  }

  public void setSslCertificateUrlTruststorePassword(String sslCertificateUrlTruststorePassword) {
    this.sslCertificateUrlTruststorePassword = sslCertificateUrlTruststorePassword;
  }

  public SamlSettings sslCertificateUrlTruststoreType(SslCertificateUrlTruststoreTypeEnum sslCertificateUrlTruststoreType) {
    this.sslCertificateUrlTruststoreType = sslCertificateUrlTruststoreType;
    return this;
  }

   /**
   * The format of the keystore file. Should be jks to use the Java Keystore format or PKCS12 to use PKCS#12 files. The default is jks.
   * @return sslCertificateUrlTruststoreType
  **/
  @Schema(description = "The format of the keystore file. Should be jks to use the Java Keystore format or PKCS12 to use PKCS#12 files. The default is jks.")
  public SslCertificateUrlTruststoreTypeEnum getSslCertificateUrlTruststoreType() {
    return sslCertificateUrlTruststoreType;
  }

  public void setSslCertificateUrlTruststoreType(SslCertificateUrlTruststoreTypeEnum sslCertificateUrlTruststoreType) {
    this.sslCertificateUrlTruststoreType = sslCertificateUrlTruststoreType;
  }

  public SamlSettings overrideYaml(String overrideYaml) {
    this.overrideYaml = overrideYaml;
    return this;
  }

   /**
   * Advanced configuration options in YAML format. Any settings defined here will override any configuration set via the API.
   * @return overrideYaml
  **/
  @Schema(description = "Advanced configuration options in YAML format. Any settings defined here will override any configuration set via the API.")
  public String getOverrideYaml() {
    return overrideYaml;
  }

  public void setOverrideYaml(String overrideYaml) {
    this.overrideYaml = overrideYaml;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SamlSettings samlSettings = (SamlSettings) o;
    return Objects.equals(this.id, samlSettings.id) &&
        Objects.equals(this.name, samlSettings.name) &&
        Objects.equals(this.idp, samlSettings.idp) &&
        Objects.equals(this.sp, samlSettings.sp) &&
        Objects.equals(this.attributes, samlSettings.attributes) &&
        Objects.equals(this.roleMappings, samlSettings.roleMappings) &&
        Objects.equals(this.enabled, samlSettings.enabled) &&
        Objects.equals(this.order, samlSettings.order) &&
        Objects.equals(this.forceAuthn, samlSettings.forceAuthn) &&
        Objects.equals(this.signingCertificateUrl, samlSettings.signingCertificateUrl) &&
        Objects.equals(this.signingCertificateUrlPassword, samlSettings.signingCertificateUrlPassword) &&
        Objects.equals(this.signingSamlMessages, samlSettings.signingSamlMessages) &&
        Objects.equals(this.encryptionCertificateUrl, samlSettings.encryptionCertificateUrl) &&
        Objects.equals(this.encryptionCertificateUrlPassword, samlSettings.encryptionCertificateUrlPassword) &&
        Objects.equals(this.sslCertificateUrl, samlSettings.sslCertificateUrl) &&
        Objects.equals(this.sslCertificateUrlTruststorePassword, samlSettings.sslCertificateUrlTruststorePassword) &&
        Objects.equals(this.sslCertificateUrlTruststoreType, samlSettings.sslCertificateUrlTruststoreType) &&
        Objects.equals(this.overrideYaml, samlSettings.overrideYaml);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, idp, sp, attributes, roleMappings, enabled, order, forceAuthn, signingCertificateUrl, signingCertificateUrlPassword, signingSamlMessages, encryptionCertificateUrl, encryptionCertificateUrlPassword, sslCertificateUrl, sslCertificateUrlTruststorePassword, sslCertificateUrlTruststoreType, overrideYaml);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SamlSettings {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    idp: ").append(toIndentedString(idp)).append("\n");
    sb.append("    sp: ").append(toIndentedString(sp)).append("\n");
    sb.append("    attributes: ").append(toIndentedString(attributes)).append("\n");
    sb.append("    roleMappings: ").append(toIndentedString(roleMappings)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    order: ").append(toIndentedString(order)).append("\n");
    sb.append("    forceAuthn: ").append(toIndentedString(forceAuthn)).append("\n");
    sb.append("    signingCertificateUrl: ").append(toIndentedString(signingCertificateUrl)).append("\n");
    sb.append("    signingCertificateUrlPassword: ").append(toIndentedString(signingCertificateUrlPassword)).append("\n");
    sb.append("    signingSamlMessages: ").append(toIndentedString(signingSamlMessages)).append("\n");
    sb.append("    encryptionCertificateUrl: ").append(toIndentedString(encryptionCertificateUrl)).append("\n");
    sb.append("    encryptionCertificateUrlPassword: ").append(toIndentedString(encryptionCertificateUrlPassword)).append("\n");
    sb.append("    sslCertificateUrl: ").append(toIndentedString(sslCertificateUrl)).append("\n");
    sb.append("    sslCertificateUrlTruststorePassword: ").append(toIndentedString(sslCertificateUrlTruststorePassword)).append("\n");
    sb.append("    sslCertificateUrlTruststoreType: ").append(toIndentedString(sslCertificateUrlTruststoreType)).append("\n");
    sb.append("    overrideYaml: ").append(toIndentedString(overrideYaml)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
