/*
 * Elastic Cloud API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.AllocatorMoveRequest;
import io.swagger.client.model.InstanceMoveRequest;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * The configuration settings for the timeout and fallback parameters.
 */
@Schema(description = "The configuration settings for the timeout and fallback parameters.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-10T16:33:30.970+05:30[Asia/Kolkata]")
public class KibanaPlanControlConfiguration {
  @SerializedName("timeout")
  private Long timeout = null;

  @SerializedName("calm_wait_time")
  private Long calmWaitTime = null;

  @SerializedName("move_instances")
  private List<InstanceMoveRequest> moveInstances = null;

  @SerializedName("move_allocators")
  private List<AllocatorMoveRequest> moveAllocators = null;

  @SerializedName("reallocate_instances")
  private Boolean reallocateInstances = null;

  @SerializedName("preferred_allocators")
  private List<String> preferredAllocators = null;

  @SerializedName("extended_maintenance")
  private Boolean extendedMaintenance = null;

  /**
   * Set to &#x27;forced&#x27; to force a reboot as part of the upgrade plan
   */
  @JsonAdapter(ClusterRebootEnum.Adapter.class)
  public enum ClusterRebootEnum {
    FORCED("forced");

    private String value;

    ClusterRebootEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ClusterRebootEnum fromValue(String text) {
      for (ClusterRebootEnum b : ClusterRebootEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ClusterRebootEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClusterRebootEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClusterRebootEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ClusterRebootEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("cluster_reboot")
  private ClusterRebootEnum clusterReboot = null;

  public KibanaPlanControlConfiguration timeout(Long timeout) {
    this.timeout = timeout;
    return this;
  }

   /**
   * The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB)
   * @return timeout
  **/
  @Schema(description = "The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB)")
  public Long getTimeout() {
    return timeout;
  }

  public void setTimeout(Long timeout) {
    this.timeout = timeout;
  }

  public KibanaPlanControlConfiguration calmWaitTime(Long calmWaitTime) {
    this.calmWaitTime = calmWaitTime;
    return this;
  }

   /**
   * This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s
   * @return calmWaitTime
  **/
  @Schema(description = "This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s")
  public Long getCalmWaitTime() {
    return calmWaitTime;
  }

  public void setCalmWaitTime(Long calmWaitTime) {
    this.calmWaitTime = calmWaitTime;
  }

  public KibanaPlanControlConfiguration moveInstances(List<InstanceMoveRequest> moveInstances) {
    this.moveInstances = moveInstances;
    return this;
  }

  public KibanaPlanControlConfiguration addMoveInstancesItem(InstanceMoveRequest moveInstancesItem) {
    if (this.moveInstances == null) {
      this.moveInstances = new ArrayList<InstanceMoveRequest>();
    }
    this.moveInstances.add(moveInstancesItem);
    return this;
  }

   /**
   * Get moveInstances
   * @return moveInstances
  **/
  @Schema(description = "")
  public List<InstanceMoveRequest> getMoveInstances() {
    return moveInstances;
  }

  public void setMoveInstances(List<InstanceMoveRequest> moveInstances) {
    this.moveInstances = moveInstances;
  }

  public KibanaPlanControlConfiguration moveAllocators(List<AllocatorMoveRequest> moveAllocators) {
    this.moveAllocators = moveAllocators;
    return this;
  }

  public KibanaPlanControlConfiguration addMoveAllocatorsItem(AllocatorMoveRequest moveAllocatorsItem) {
    if (this.moveAllocators == null) {
      this.moveAllocators = new ArrayList<AllocatorMoveRequest>();
    }
    this.moveAllocators.add(moveAllocatorsItem);
    return this;
  }

   /**
   * Get moveAllocators
   * @return moveAllocators
  **/
  @Schema(description = "")
  public List<AllocatorMoveRequest> getMoveAllocators() {
    return moveAllocators;
  }

  public void setMoveAllocators(List<AllocatorMoveRequest> moveAllocators) {
    this.moveAllocators = moveAllocators;
  }

  public KibanaPlanControlConfiguration reallocateInstances(Boolean reallocateInstances) {
    this.reallocateInstances = reallocateInstances;
    return this;
  }

   /**
   * If true (default: false) does not allow re-using any existing instances currently in the cluster, ie even unchanged instances will be re-created
   * @return reallocateInstances
  **/
  @Schema(description = "If true (default: false) does not allow re-using any existing instances currently in the cluster, ie even unchanged instances will be re-created")
  public Boolean isReallocateInstances() {
    return reallocateInstances;
  }

  public void setReallocateInstances(Boolean reallocateInstances) {
    this.reallocateInstances = reallocateInstances;
  }

  public KibanaPlanControlConfiguration preferredAllocators(List<String> preferredAllocators) {
    this.preferredAllocators = preferredAllocators;
    return this;
  }

  public KibanaPlanControlConfiguration addPreferredAllocatorsItem(String preferredAllocatorsItem) {
    if (this.preferredAllocators == null) {
      this.preferredAllocators = new ArrayList<String>();
    }
    this.preferredAllocators.add(preferredAllocatorsItem);
    return this;
  }

   /**
   * List of allocators on which instances are placed if possible (if not possible/not specified then any available allocator with space is used)
   * @return preferredAllocators
  **/
  @Schema(description = "List of allocators on which instances are placed if possible (if not possible/not specified then any available allocator with space is used)")
  public List<String> getPreferredAllocators() {
    return preferredAllocators;
  }

  public void setPreferredAllocators(List<String> preferredAllocators) {
    this.preferredAllocators = preferredAllocators;
  }

  public KibanaPlanControlConfiguration extendedMaintenance(Boolean extendedMaintenance) {
    this.extendedMaintenance = extendedMaintenance;
    return this;
  }

   /**
   * If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster
   * @return extendedMaintenance
  **/
  @Schema(description = "If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster")
  public Boolean isExtendedMaintenance() {
    return extendedMaintenance;
  }

  public void setExtendedMaintenance(Boolean extendedMaintenance) {
    this.extendedMaintenance = extendedMaintenance;
  }

  public KibanaPlanControlConfiguration clusterReboot(ClusterRebootEnum clusterReboot) {
    this.clusterReboot = clusterReboot;
    return this;
  }

   /**
   * Set to &#x27;forced&#x27; to force a reboot as part of the upgrade plan
   * @return clusterReboot
  **/
  @Schema(description = "Set to 'forced' to force a reboot as part of the upgrade plan")
  public ClusterRebootEnum getClusterReboot() {
    return clusterReboot;
  }

  public void setClusterReboot(ClusterRebootEnum clusterReboot) {
    this.clusterReboot = clusterReboot;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KibanaPlanControlConfiguration kibanaPlanControlConfiguration = (KibanaPlanControlConfiguration) o;
    return Objects.equals(this.timeout, kibanaPlanControlConfiguration.timeout) &&
        Objects.equals(this.calmWaitTime, kibanaPlanControlConfiguration.calmWaitTime) &&
        Objects.equals(this.moveInstances, kibanaPlanControlConfiguration.moveInstances) &&
        Objects.equals(this.moveAllocators, kibanaPlanControlConfiguration.moveAllocators) &&
        Objects.equals(this.reallocateInstances, kibanaPlanControlConfiguration.reallocateInstances) &&
        Objects.equals(this.preferredAllocators, kibanaPlanControlConfiguration.preferredAllocators) &&
        Objects.equals(this.extendedMaintenance, kibanaPlanControlConfiguration.extendedMaintenance) &&
        Objects.equals(this.clusterReboot, kibanaPlanControlConfiguration.clusterReboot);
  }

  @Override
  public int hashCode() {
    return Objects.hash(timeout, calmWaitTime, moveInstances, moveAllocators, reallocateInstances, preferredAllocators, extendedMaintenance, clusterReboot);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KibanaPlanControlConfiguration {\n");
    
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    calmWaitTime: ").append(toIndentedString(calmWaitTime)).append("\n");
    sb.append("    moveInstances: ").append(toIndentedString(moveInstances)).append("\n");
    sb.append("    moveAllocators: ").append(toIndentedString(moveAllocators)).append("\n");
    sb.append("    reallocateInstances: ").append(toIndentedString(reallocateInstances)).append("\n");
    sb.append("    preferredAllocators: ").append(toIndentedString(preferredAllocators)).append("\n");
    sb.append("    extendedMaintenance: ").append(toIndentedString(extendedMaintenance)).append("\n");
    sb.append("    clusterReboot: ").append(toIndentedString(clusterReboot)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
