/*
 * Elastic Cloud API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.AllocatorMoveRequest;
import io.swagger.client.model.InstanceMoveRequest;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * The configuration settings for the timeout and fallback parameters.
 */
@Schema(description = "The configuration settings for the timeout and fallback parameters.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-10T16:33:30.970+05:30[Asia/Kolkata]")
public class ElasticsearchPlanControlConfiguration {
  @SerializedName("timeout")
  private Long timeout = null;

  @SerializedName("calm_wait_time")
  private Long calmWaitTime = null;

  @SerializedName("move_instances")
  private List<InstanceMoveRequest> moveInstances = null;

  @SerializedName("move_allocators")
  private List<AllocatorMoveRequest> moveAllocators = null;

  @SerializedName("move_only")
  private Boolean moveOnly = null;

  @SerializedName("reallocate_instances")
  private Boolean reallocateInstances = null;

  @SerializedName("preferred_allocators")
  private List<String> preferredAllocators = null;

  @SerializedName("skip_snapshot")
  private Boolean skipSnapshot = null;

  @SerializedName("max_snapshot_attempts")
  private Integer maxSnapshotAttempts = null;

  @SerializedName("max_snapshot_age")
  private Long maxSnapshotAge = null;

  @SerializedName("extended_maintenance")
  private Boolean extendedMaintenance = null;

  /**
   * Set to &#x27;forced&#x27; to force a reboot as part of the upgrade plan. NOTES: (ie taking an existing plan and leaving it alone except for setting &#x27;transient.plan_configuration.cluster_reboot&#x27;: &#x27;forced&#x27; will reboot the cluster)
   */
  @JsonAdapter(ClusterRebootEnum.Adapter.class)
  public enum ClusterRebootEnum {
    FORCED("forced");

    private String value;

    ClusterRebootEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ClusterRebootEnum fromValue(String text) {
      for (ClusterRebootEnum b : ClusterRebootEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ClusterRebootEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClusterRebootEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClusterRebootEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ClusterRebootEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("cluster_reboot")
  private ClusterRebootEnum clusterReboot = null;

  @SerializedName("override_failsafe")
  private Boolean overrideFailsafe = null;

  @SerializedName("skip_data_migration")
  private Boolean skipDataMigration = null;

  @SerializedName("skip_upgrade_checker")
  private Boolean skipUpgradeChecker = null;

  @SerializedName("skip_post_upgrade_steps")
  private Boolean skipPostUpgradeSteps = null;

  @SerializedName("skip_snapshot_post_major_upgrade")
  private Boolean skipSnapshotPostMajorUpgrade = null;

  public ElasticsearchPlanControlConfiguration timeout(Long timeout) {
    this.timeout = timeout;
    return this;
  }

   /**
   * The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB). NOTES: (eg a 3 zone cluster with 2 nodes of 2048 each would have a timeout of 4*2048&#x3D;8192 seconds)
   * @return timeout
  **/
  @Schema(description = "The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB). NOTES: (eg a 3 zone cluster with 2 nodes of 2048 each would have a timeout of 4*2048=8192 seconds)")
  public Long getTimeout() {
    return timeout;
  }

  public void setTimeout(Long timeout) {
    this.timeout = timeout;
  }

  public ElasticsearchPlanControlConfiguration calmWaitTime(Long calmWaitTime) {
    this.calmWaitTime = calmWaitTime;
    return this;
  }

   /**
   * This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s
   * @return calmWaitTime
  **/
  @Schema(description = "This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s")
  public Long getCalmWaitTime() {
    return calmWaitTime;
  }

  public void setCalmWaitTime(Long calmWaitTime) {
    this.calmWaitTime = calmWaitTime;
  }

  public ElasticsearchPlanControlConfiguration moveInstances(List<InstanceMoveRequest> moveInstances) {
    this.moveInstances = moveInstances;
    return this;
  }

  public ElasticsearchPlanControlConfiguration addMoveInstancesItem(InstanceMoveRequest moveInstancesItem) {
    if (this.moveInstances == null) {
      this.moveInstances = new ArrayList<InstanceMoveRequest>();
    }
    this.moveInstances.add(moveInstancesItem);
    return this;
  }

   /**
   * Get moveInstances
   * @return moveInstances
  **/
  @Schema(description = "")
  public List<InstanceMoveRequest> getMoveInstances() {
    return moveInstances;
  }

  public void setMoveInstances(List<InstanceMoveRequest> moveInstances) {
    this.moveInstances = moveInstances;
  }

  public ElasticsearchPlanControlConfiguration moveAllocators(List<AllocatorMoveRequest> moveAllocators) {
    this.moveAllocators = moveAllocators;
    return this;
  }

  public ElasticsearchPlanControlConfiguration addMoveAllocatorsItem(AllocatorMoveRequest moveAllocatorsItem) {
    if (this.moveAllocators == null) {
      this.moveAllocators = new ArrayList<AllocatorMoveRequest>();
    }
    this.moveAllocators.add(moveAllocatorsItem);
    return this;
  }

   /**
   * Get moveAllocators
   * @return moveAllocators
  **/
  @Schema(description = "")
  public List<AllocatorMoveRequest> getMoveAllocators() {
    return moveAllocators;
  }

  public void setMoveAllocators(List<AllocatorMoveRequest> moveAllocators) {
    this.moveAllocators = moveAllocators;
  }

  public ElasticsearchPlanControlConfiguration moveOnly(Boolean moveOnly) {
    this.moveOnly = moveOnly;
    return this;
  }

   /**
   * If true (default: false) only move_instances and move_allocators instructions will be executed, all other changes will be ignored
   * @return moveOnly
  **/
  @Schema(description = "If true (default: false) only move_instances and move_allocators instructions will be executed, all other changes will be ignored")
  public Boolean isMoveOnly() {
    return moveOnly;
  }

  public void setMoveOnly(Boolean moveOnly) {
    this.moveOnly = moveOnly;
  }

  public ElasticsearchPlanControlConfiguration reallocateInstances(Boolean reallocateInstances) {
    this.reallocateInstances = reallocateInstances;
    return this;
  }

   /**
   * If true (default: false) does not allow re-using any existing instances currently in the cluster, ie even unchanged instances will be re-created
   * @return reallocateInstances
  **/
  @Schema(description = "If true (default: false) does not allow re-using any existing instances currently in the cluster, ie even unchanged instances will be re-created")
  public Boolean isReallocateInstances() {
    return reallocateInstances;
  }

  public void setReallocateInstances(Boolean reallocateInstances) {
    this.reallocateInstances = reallocateInstances;
  }

  public ElasticsearchPlanControlConfiguration preferredAllocators(List<String> preferredAllocators) {
    this.preferredAllocators = preferredAllocators;
    return this;
  }

  public ElasticsearchPlanControlConfiguration addPreferredAllocatorsItem(String preferredAllocatorsItem) {
    if (this.preferredAllocators == null) {
      this.preferredAllocators = new ArrayList<String>();
    }
    this.preferredAllocators.add(preferredAllocatorsItem);
    return this;
  }

   /**
   * List of allocators on which instances are placed if possible (if not possible/not specified then any available allocator with space is used)
   * @return preferredAllocators
  **/
  @Schema(description = "List of allocators on which instances are placed if possible (if not possible/not specified then any available allocator with space is used)")
  public List<String> getPreferredAllocators() {
    return preferredAllocators;
  }

  public void setPreferredAllocators(List<String> preferredAllocators) {
    this.preferredAllocators = preferredAllocators;
  }

  public ElasticsearchPlanControlConfiguration skipSnapshot(Boolean skipSnapshot) {
    this.skipSnapshot = skipSnapshot;
    return this;
  }

   /**
   * If true (default: false), does not take (or require) a successful snapshot to be taken before performing any potentially destructive changes to this cluster
   * @return skipSnapshot
  **/
  @Schema(description = "If true (default: false), does not take (or require) a successful snapshot to be taken before performing any potentially destructive changes to this cluster")
  public Boolean isSkipSnapshot() {
    return skipSnapshot;
  }

  public void setSkipSnapshot(Boolean skipSnapshot) {
    this.skipSnapshot = skipSnapshot;
  }

  public ElasticsearchPlanControlConfiguration maxSnapshotAttempts(Integer maxSnapshotAttempts) {
    this.maxSnapshotAttempts = maxSnapshotAttempts;
    return this;
  }

   /**
   * If taking a snapshot (ie unless &#x27;skip_snapshots&#x27;: true) then will retry on failure at most this number of times (default: 5)
   * @return maxSnapshotAttempts
  **/
  @Schema(description = "If taking a snapshot (ie unless 'skip_snapshots': true) then will retry on failure at most this number of times (default: 5)")
  public Integer getMaxSnapshotAttempts() {
    return maxSnapshotAttempts;
  }

  public void setMaxSnapshotAttempts(Integer maxSnapshotAttempts) {
    this.maxSnapshotAttempts = maxSnapshotAttempts;
  }

  public ElasticsearchPlanControlConfiguration maxSnapshotAge(Long maxSnapshotAge) {
    this.maxSnapshotAge = maxSnapshotAge;
    return this;
  }

   /**
   * When you take a snapshot and &#x27;skip_snapshots&#x27; is false, specifies the maximum age in seconds of the most recent snapshot before a new snapshot is created. Default is 300
   * @return maxSnapshotAge
  **/
  @Schema(description = "When you take a snapshot and 'skip_snapshots' is false, specifies the maximum age in seconds of the most recent snapshot before a new snapshot is created. Default is 300")
  public Long getMaxSnapshotAge() {
    return maxSnapshotAge;
  }

  public void setMaxSnapshotAge(Long maxSnapshotAge) {
    this.maxSnapshotAge = maxSnapshotAge;
  }

  public ElasticsearchPlanControlConfiguration extendedMaintenance(Boolean extendedMaintenance) {
    this.extendedMaintenance = extendedMaintenance;
    return this;
  }

   /**
   * If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster
   * @return extendedMaintenance
  **/
  @Schema(description = "If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster")
  public Boolean isExtendedMaintenance() {
    return extendedMaintenance;
  }

  public void setExtendedMaintenance(Boolean extendedMaintenance) {
    this.extendedMaintenance = extendedMaintenance;
  }

  public ElasticsearchPlanControlConfiguration clusterReboot(ClusterRebootEnum clusterReboot) {
    this.clusterReboot = clusterReboot;
    return this;
  }

   /**
   * Set to &#x27;forced&#x27; to force a reboot as part of the upgrade plan. NOTES: (ie taking an existing plan and leaving it alone except for setting &#x27;transient.plan_configuration.cluster_reboot&#x27;: &#x27;forced&#x27; will reboot the cluster)
   * @return clusterReboot
  **/
  @Schema(description = "Set to 'forced' to force a reboot as part of the upgrade plan. NOTES: (ie taking an existing plan and leaving it alone except for setting 'transient.plan_configuration.cluster_reboot': 'forced' will reboot the cluster)")
  public ClusterRebootEnum getClusterReboot() {
    return clusterReboot;
  }

  public void setClusterReboot(ClusterRebootEnum clusterReboot) {
    this.clusterReboot = clusterReboot;
  }

  public ElasticsearchPlanControlConfiguration overrideFailsafe(Boolean overrideFailsafe) {
    this.overrideFailsafe = overrideFailsafe;
    return this;
  }

   /**
   * If false (the default) then the plan will fail out if it believes the requested sequence of operations can result in data loss - this flag will override some of these restraints
   * @return overrideFailsafe
  **/
  @Schema(description = "If false (the default) then the plan will fail out if it believes the requested sequence of operations can result in data loss - this flag will override some of these restraints")
  public Boolean isOverrideFailsafe() {
    return overrideFailsafe;
  }

  public void setOverrideFailsafe(Boolean overrideFailsafe) {
    this.overrideFailsafe = overrideFailsafe;
  }

  public ElasticsearchPlanControlConfiguration skipDataMigration(Boolean skipDataMigration) {
    this.skipDataMigration = skipDataMigration;
    return this;
  }

   /**
   * If true (default: false) then the plan will not wait for data to be migrated from old instances to new instances before continuing the plan (potentially deleting the old instances and losing data)
   * @return skipDataMigration
  **/
  @Schema(description = "If true (default: false) then the plan will not wait for data to be migrated from old instances to new instances before continuing the plan (potentially deleting the old instances and losing data)")
  public Boolean isSkipDataMigration() {
    return skipDataMigration;
  }

  public void setSkipDataMigration(Boolean skipDataMigration) {
    this.skipDataMigration = skipDataMigration;
  }

  public ElasticsearchPlanControlConfiguration skipUpgradeChecker(Boolean skipUpgradeChecker) {
    this.skipUpgradeChecker = skipUpgradeChecker;
    return this;
  }

   /**
   * If false, the cluster is checked for issues that should be resolved before migration (eg contains old Lucene segments), if true this is bypassed
   * @return skipUpgradeChecker
  **/
  @Schema(description = "If false, the cluster is checked for issues that should be resolved before migration (eg contains old Lucene segments), if true this is bypassed")
  public Boolean isSkipUpgradeChecker() {
    return skipUpgradeChecker;
  }

  public void setSkipUpgradeChecker(Boolean skipUpgradeChecker) {
    this.skipUpgradeChecker = skipUpgradeChecker;
  }

  public ElasticsearchPlanControlConfiguration skipPostUpgradeSteps(Boolean skipPostUpgradeSteps) {
    this.skipPostUpgradeSteps = skipPostUpgradeSteps;
    return this;
  }

   /**
   * If false (the default), the cluster will run (currently) 2.x-&gt;5.x operations for any plan change ending with a 5.x cluster (eg apply a cluster license, ensure Monitoring is configured)
   * @return skipPostUpgradeSteps
  **/
  @Schema(description = "If false (the default), the cluster will run (currently) 2.x->5.x operations for any plan change ending with a 5.x cluster (eg apply a cluster license, ensure Monitoring is configured)")
  public Boolean isSkipPostUpgradeSteps() {
    return skipPostUpgradeSteps;
  }

  public void setSkipPostUpgradeSteps(Boolean skipPostUpgradeSteps) {
    this.skipPostUpgradeSteps = skipPostUpgradeSteps;
  }

  public ElasticsearchPlanControlConfiguration skipSnapshotPostMajorUpgrade(Boolean skipSnapshotPostMajorUpgrade) {
    this.skipSnapshotPostMajorUpgrade = skipSnapshotPostMajorUpgrade;
    return this;
  }

   /**
   * If false (the default), the cluster will perform a snapshot after a major version upgrade takes place
   * @return skipSnapshotPostMajorUpgrade
  **/
  @Schema(description = "If false (the default), the cluster will perform a snapshot after a major version upgrade takes place")
  public Boolean isSkipSnapshotPostMajorUpgrade() {
    return skipSnapshotPostMajorUpgrade;
  }

  public void setSkipSnapshotPostMajorUpgrade(Boolean skipSnapshotPostMajorUpgrade) {
    this.skipSnapshotPostMajorUpgrade = skipSnapshotPostMajorUpgrade;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ElasticsearchPlanControlConfiguration elasticsearchPlanControlConfiguration = (ElasticsearchPlanControlConfiguration) o;
    return Objects.equals(this.timeout, elasticsearchPlanControlConfiguration.timeout) &&
        Objects.equals(this.calmWaitTime, elasticsearchPlanControlConfiguration.calmWaitTime) &&
        Objects.equals(this.moveInstances, elasticsearchPlanControlConfiguration.moveInstances) &&
        Objects.equals(this.moveAllocators, elasticsearchPlanControlConfiguration.moveAllocators) &&
        Objects.equals(this.moveOnly, elasticsearchPlanControlConfiguration.moveOnly) &&
        Objects.equals(this.reallocateInstances, elasticsearchPlanControlConfiguration.reallocateInstances) &&
        Objects.equals(this.preferredAllocators, elasticsearchPlanControlConfiguration.preferredAllocators) &&
        Objects.equals(this.skipSnapshot, elasticsearchPlanControlConfiguration.skipSnapshot) &&
        Objects.equals(this.maxSnapshotAttempts, elasticsearchPlanControlConfiguration.maxSnapshotAttempts) &&
        Objects.equals(this.maxSnapshotAge, elasticsearchPlanControlConfiguration.maxSnapshotAge) &&
        Objects.equals(this.extendedMaintenance, elasticsearchPlanControlConfiguration.extendedMaintenance) &&
        Objects.equals(this.clusterReboot, elasticsearchPlanControlConfiguration.clusterReboot) &&
        Objects.equals(this.overrideFailsafe, elasticsearchPlanControlConfiguration.overrideFailsafe) &&
        Objects.equals(this.skipDataMigration, elasticsearchPlanControlConfiguration.skipDataMigration) &&
        Objects.equals(this.skipUpgradeChecker, elasticsearchPlanControlConfiguration.skipUpgradeChecker) &&
        Objects.equals(this.skipPostUpgradeSteps, elasticsearchPlanControlConfiguration.skipPostUpgradeSteps) &&
        Objects.equals(this.skipSnapshotPostMajorUpgrade, elasticsearchPlanControlConfiguration.skipSnapshotPostMajorUpgrade);
  }

  @Override
  public int hashCode() {
    return Objects.hash(timeout, calmWaitTime, moveInstances, moveAllocators, moveOnly, reallocateInstances, preferredAllocators, skipSnapshot, maxSnapshotAttempts, maxSnapshotAge, extendedMaintenance, clusterReboot, overrideFailsafe, skipDataMigration, skipUpgradeChecker, skipPostUpgradeSteps, skipSnapshotPostMajorUpgrade);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ElasticsearchPlanControlConfiguration {\n");
    
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    calmWaitTime: ").append(toIndentedString(calmWaitTime)).append("\n");
    sb.append("    moveInstances: ").append(toIndentedString(moveInstances)).append("\n");
    sb.append("    moveAllocators: ").append(toIndentedString(moveAllocators)).append("\n");
    sb.append("    moveOnly: ").append(toIndentedString(moveOnly)).append("\n");
    sb.append("    reallocateInstances: ").append(toIndentedString(reallocateInstances)).append("\n");
    sb.append("    preferredAllocators: ").append(toIndentedString(preferredAllocators)).append("\n");
    sb.append("    skipSnapshot: ").append(toIndentedString(skipSnapshot)).append("\n");
    sb.append("    maxSnapshotAttempts: ").append(toIndentedString(maxSnapshotAttempts)).append("\n");
    sb.append("    maxSnapshotAge: ").append(toIndentedString(maxSnapshotAge)).append("\n");
    sb.append("    extendedMaintenance: ").append(toIndentedString(extendedMaintenance)).append("\n");
    sb.append("    clusterReboot: ").append(toIndentedString(clusterReboot)).append("\n");
    sb.append("    overrideFailsafe: ").append(toIndentedString(overrideFailsafe)).append("\n");
    sb.append("    skipDataMigration: ").append(toIndentedString(skipDataMigration)).append("\n");
    sb.append("    skipUpgradeChecker: ").append(toIndentedString(skipUpgradeChecker)).append("\n");
    sb.append("    skipPostUpgradeSteps: ").append(toIndentedString(skipPostUpgradeSteps)).append("\n");
    sb.append("    skipSnapshotPostMajorUpgrade: ").append(toIndentedString(skipSnapshotPostMajorUpgrade)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
