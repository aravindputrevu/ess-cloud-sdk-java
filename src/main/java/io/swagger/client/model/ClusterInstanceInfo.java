/*
 * Elastic Cloud API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ClusterInstanceConfigurationInfo;
import io.swagger.client.model.ClusterInstanceDiskInfo;
import io.swagger.client.model.ClusterInstanceMemoryInfo;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Information about each Kibana instance and APM Server in the Elasticsearch cluster.
 */
@Schema(description = "Information about each Kibana instance and APM Server in the Elasticsearch cluster.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-10T16:33:30.970+05:30[Asia/Kolkata]")
public class ClusterInstanceInfo {
  @SerializedName("instance_name")
  private String instanceName = null;

  @SerializedName("instance_configuration")
  private ClusterInstanceConfigurationInfo instanceConfiguration = null;

  @SerializedName("service_version")
  private String serviceVersion = null;

  @SerializedName("service_id")
  private String serviceId = null;

  @SerializedName("healthy")
  private Boolean healthy = null;

  @SerializedName("container_started")
  private Boolean containerStarted = null;

  @SerializedName("service_running")
  private Boolean serviceRunning = null;

  @SerializedName("maintenance_mode")
  private Boolean maintenanceMode = null;

  @SerializedName("zone")
  private String zone = null;

  @SerializedName("allocator_id")
  private String allocatorId = null;

  @SerializedName("memory")
  private ClusterInstanceMemoryInfo memory = null;

  @SerializedName("disk")
  private ClusterInstanceDiskInfo disk = null;

  @SerializedName("service_roles")
  private List<String> serviceRoles = null;

  public ClusterInstanceInfo instanceName(String instanceName) {
    this.instanceName = instanceName;
    return this;
  }

   /**
   * Whether the instance is healthy (ie started and running)
   * @return instanceName
  **/
  @Schema(required = true, description = "Whether the instance is healthy (ie started and running)")
  public String getInstanceName() {
    return instanceName;
  }

  public void setInstanceName(String instanceName) {
    this.instanceName = instanceName;
  }

  public ClusterInstanceInfo instanceConfiguration(ClusterInstanceConfigurationInfo instanceConfiguration) {
    this.instanceConfiguration = instanceConfiguration;
    return this;
  }

   /**
   * Get instanceConfiguration
   * @return instanceConfiguration
  **/
  @Schema(description = "")
  public ClusterInstanceConfigurationInfo getInstanceConfiguration() {
    return instanceConfiguration;
  }

  public void setInstanceConfiguration(ClusterInstanceConfigurationInfo instanceConfiguration) {
    this.instanceConfiguration = instanceConfiguration;
  }

  public ClusterInstanceInfo serviceVersion(String serviceVersion) {
    this.serviceVersion = serviceVersion;
    return this;
  }

   /**
   * The version of the service that the instance is running (eg Elasticsearch or Kibana), if available
   * @return serviceVersion
  **/
  @Schema(description = "The version of the service that the instance is running (eg Elasticsearch or Kibana), if available")
  public String getServiceVersion() {
    return serviceVersion;
  }

  public void setServiceVersion(String serviceVersion) {
    this.serviceVersion = serviceVersion;
  }

  public ClusterInstanceInfo serviceId(String serviceId) {
    this.serviceId = serviceId;
    return this;
  }

   /**
   * The service-specific (eg Elasticsearch) id of the node, if available
   * @return serviceId
  **/
  @Schema(description = "The service-specific (eg Elasticsearch) id of the node, if available")
  public String getServiceId() {
    return serviceId;
  }

  public void setServiceId(String serviceId) {
    this.serviceId = serviceId;
  }

  public ClusterInstanceInfo healthy(Boolean healthy) {
    this.healthy = healthy;
    return this;
  }

   /**
   * Whether the instance is healthy (ie started and running)
   * @return healthy
  **/
  @Schema(required = true, description = "Whether the instance is healthy (ie started and running)")
  public Boolean isHealthy() {
    return healthy;
  }

  public void setHealthy(Boolean healthy) {
    this.healthy = healthy;
  }

  public ClusterInstanceInfo containerStarted(Boolean containerStarted) {
    this.containerStarted = containerStarted;
    return this;
  }

   /**
   * Whether the container has started (does not tell you anything about the service -ie Elasticsearch- running inside the container)
   * @return containerStarted
  **/
  @Schema(required = true, description = "Whether the container has started (does not tell you anything about the service -ie Elasticsearch- running inside the container)")
  public Boolean isContainerStarted() {
    return containerStarted;
  }

  public void setContainerStarted(Boolean containerStarted) {
    this.containerStarted = containerStarted;
  }

  public ClusterInstanceInfo serviceRunning(Boolean serviceRunning) {
    this.serviceRunning = serviceRunning;
    return this;
  }

   /**
   * Whether the service launched inside the container -ie Elasticsearch- is actually running
   * @return serviceRunning
  **/
  @Schema(required = true, description = "Whether the service launched inside the container -ie Elasticsearch- is actually running")
  public Boolean isServiceRunning() {
    return serviceRunning;
  }

  public void setServiceRunning(Boolean serviceRunning) {
    this.serviceRunning = serviceRunning;
  }

  public ClusterInstanceInfo maintenanceMode(Boolean maintenanceMode) {
    this.maintenanceMode = maintenanceMode;
    return this;
  }

   /**
   * Whether the service is is maintenance mode (meaning that the proxy is not routing external traffic to it)
   * @return maintenanceMode
  **/
  @Schema(required = true, description = "Whether the service is is maintenance mode (meaning that the proxy is not routing external traffic to it)")
  public Boolean isMaintenanceMode() {
    return maintenanceMode;
  }

  public void setMaintenanceMode(Boolean maintenanceMode) {
    this.maintenanceMode = maintenanceMode;
  }

  public ClusterInstanceInfo zone(String zone) {
    this.zone = zone;
    return this;
  }

   /**
   * The zone in which this instance is being allocated
   * @return zone
  **/
  @Schema(description = "The zone in which this instance is being allocated")
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }

  public ClusterInstanceInfo allocatorId(String allocatorId) {
    this.allocatorId = allocatorId;
    return this;
  }

   /**
   * The id of the allocator on which this instance is running (if the container is started or starting)
   * @return allocatorId
  **/
  @Schema(description = "The id of the allocator on which this instance is running (if the container is started or starting)")
  public String getAllocatorId() {
    return allocatorId;
  }

  public void setAllocatorId(String allocatorId) {
    this.allocatorId = allocatorId;
  }

  public ClusterInstanceInfo memory(ClusterInstanceMemoryInfo memory) {
    this.memory = memory;
    return this;
  }

   /**
   * Get memory
   * @return memory
  **/
  @Schema(description = "")
  public ClusterInstanceMemoryInfo getMemory() {
    return memory;
  }

  public void setMemory(ClusterInstanceMemoryInfo memory) {
    this.memory = memory;
  }

  public ClusterInstanceInfo disk(ClusterInstanceDiskInfo disk) {
    this.disk = disk;
    return this;
  }

   /**
   * Get disk
   * @return disk
  **/
  @Schema(description = "")
  public ClusterInstanceDiskInfo getDisk() {
    return disk;
  }

  public void setDisk(ClusterInstanceDiskInfo disk) {
    this.disk = disk;
  }

  public ClusterInstanceInfo serviceRoles(List<String> serviceRoles) {
    this.serviceRoles = serviceRoles;
    return this;
  }

  public ClusterInstanceInfo addServiceRolesItem(String serviceRolesItem) {
    if (this.serviceRoles == null) {
      this.serviceRoles = new ArrayList<String>();
    }
    this.serviceRoles.add(serviceRolesItem);
    return this;
  }

   /**
   * List of roles assigned to the service running in the instance. Currently only populated for Elasticsearch, with possible values: master,data,ingest,ml
   * @return serviceRoles
  **/
  @Schema(description = "List of roles assigned to the service running in the instance. Currently only populated for Elasticsearch, with possible values: master,data,ingest,ml")
  public List<String> getServiceRoles() {
    return serviceRoles;
  }

  public void setServiceRoles(List<String> serviceRoles) {
    this.serviceRoles = serviceRoles;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ClusterInstanceInfo clusterInstanceInfo = (ClusterInstanceInfo) o;
    return Objects.equals(this.instanceName, clusterInstanceInfo.instanceName) &&
        Objects.equals(this.instanceConfiguration, clusterInstanceInfo.instanceConfiguration) &&
        Objects.equals(this.serviceVersion, clusterInstanceInfo.serviceVersion) &&
        Objects.equals(this.serviceId, clusterInstanceInfo.serviceId) &&
        Objects.equals(this.healthy, clusterInstanceInfo.healthy) &&
        Objects.equals(this.containerStarted, clusterInstanceInfo.containerStarted) &&
        Objects.equals(this.serviceRunning, clusterInstanceInfo.serviceRunning) &&
        Objects.equals(this.maintenanceMode, clusterInstanceInfo.maintenanceMode) &&
        Objects.equals(this.zone, clusterInstanceInfo.zone) &&
        Objects.equals(this.allocatorId, clusterInstanceInfo.allocatorId) &&
        Objects.equals(this.memory, clusterInstanceInfo.memory) &&
        Objects.equals(this.disk, clusterInstanceInfo.disk) &&
        Objects.equals(this.serviceRoles, clusterInstanceInfo.serviceRoles);
  }

  @Override
  public int hashCode() {
    return Objects.hash(instanceName, instanceConfiguration, serviceVersion, serviceId, healthy, containerStarted, serviceRunning, maintenanceMode, zone, allocatorId, memory, disk, serviceRoles);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ClusterInstanceInfo {\n");
    
    sb.append("    instanceName: ").append(toIndentedString(instanceName)).append("\n");
    sb.append("    instanceConfiguration: ").append(toIndentedString(instanceConfiguration)).append("\n");
    sb.append("    serviceVersion: ").append(toIndentedString(serviceVersion)).append("\n");
    sb.append("    serviceId: ").append(toIndentedString(serviceId)).append("\n");
    sb.append("    healthy: ").append(toIndentedString(healthy)).append("\n");
    sb.append("    containerStarted: ").append(toIndentedString(containerStarted)).append("\n");
    sb.append("    serviceRunning: ").append(toIndentedString(serviceRunning)).append("\n");
    sb.append("    maintenanceMode: ").append(toIndentedString(maintenanceMode)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("    allocatorId: ").append(toIndentedString(allocatorId)).append("\n");
    sb.append("    memory: ").append(toIndentedString(memory)).append("\n");
    sb.append("    disk: ").append(toIndentedString(disk)).append("\n");
    sb.append("    serviceRoles: ").append(toIndentedString(serviceRoles)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
